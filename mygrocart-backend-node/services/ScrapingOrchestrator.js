const ShopRiteScraper = require('../scrapers/ShopRiteScraper');
const TargetScraper = require('../scrapers/TargetScraper');
const OpenFoodFactsScraper = require('../scrapers/OpenFoodFactsScraper');
const ProductService = require('./ProductService');
// Import models from index.js to ensure associations are loaded
const { Store } = require('../models');

class ScrapingOrchestrator {
  constructor() {
    this.shopRiteScraper = new ShopRiteScraper();

    // TargetScraper is optional (requires API key)
    try {
      this.targetScraper = new TargetScraper();
    } catch (error) {
      // Silently skip - Target scraping is optional
      this.targetScraper = null;
    }

    this.openFoodFactsScraper = new OpenFoodFactsScraper();
    this.productService = new ProductService();
    this.isRunning = false;
  }

  /**
   * Scrape products from ShopRite and save to database
   * @param {object} options - Scraping options
   * @returns {Promise<object>} - Scraping results
   */
  async scrapeShopRite(options = {}) {
    const {
      searchTerms = ['milk', 'bread', 'eggs', 'chicken', 'apples'],
      zipCode = '07001',
      storeId = '3000', // ShopRite store ID
      maxResultsPerTerm = 10
    } = options;

    if (this.isRunning) {
      throw new Error('Scraping is already in progress');
    }

    this.isRunning = true;
    const startTime = Date.now();

    try {
      console.log('Starting ShopRite scraping process...');
      console.log(`Store ID: ${storeId}, ZIP Code: ${zipCode}`);

      // Ensure ShopRite store exists in database
      // Note: storeId (UUID) will be auto-generated by database
      const shopRiteStore = await this.ensureStoreExists({
        chainName: 'ShopRite',
        storeName: `ShopRite Store ${storeId}`,
        address: 'Various Locations',
        city: 'New York',
        state: 'NY',
        zipCode: zipCode,
        latitude: 40.7128,
        longitude: -74.0060,
        externalStoreId: storeId // Store ShopRite's store ID separately
      });

      const allScrapedProducts = [];
      const termResults = {};

      // Scrape products for each search term
      for (const searchTerm of searchTerms) {
        try {
          console.log(`Scraping products for: ${searchTerm}`);

          // Pass storeId, zipCode, and limit to searchProducts
          const products = await this.shopRiteScraper.searchProducts(
            searchTerm,
            storeId,
            zipCode,
            maxResultsPerTerm
          );

          termResults[searchTerm] = {
            found: products.length,
            withUPC: products.filter(p => p.upc).length,
            withPrice: products.filter(p => p.price !== null).length
          };

          allScrapedProducts.push(...products);

          // Add delay between requests (15 seconds for ShopRite bulk scraping)
          await this.delay(15000);

        } catch (error) {
          console.error(`Error scraping ${searchTerm}:`, error.message);
          termResults[searchTerm] = {
            error: error.message
          };
        }
      }

      // Close browser after scraping
      await this.shopRiteScraper.close();

      // Process and save scraped products to database
      console.log(`Processing ${allScrapedProducts.length} scraped products...`);
      const processingResults = await this.productService.processScrapedProducts(
        allScrapedProducts,
        shopRiteStore.storeId // Use the generated UUID
      );

      const endTime = Date.now();
      const duration = Math.round((endTime - startTime) / 1000);

      const results = {
        success: true,
        store: 'ShopRite',
        storeId: storeId,
        zipCode: zipCode,
        duration: `${duration} seconds`,
        searchTerms: searchTerms,
        termResults: termResults,
        totalProductsFound: allScrapedProducts.length,
        processingResults: processingResults,
        timestamp: new Date().toISOString()
      };

      console.log('ShopRite scraping completed successfully:', results);
      return results;

    } catch (error) {
      console.error('ShopRite scraping failed:', error.message);
      // Ensure browser is closed on error
      await this.shopRiteScraper.close();
      throw error;
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Scrape products from Target and save to database
   * @param {object} options - Scraping options
   * @returns {Promise<object>} - Scraping results
   */
  async scrapeTarget(options = {}) {
    const {
      searchTerms = ['milk', 'bread', 'eggs', 'chicken', 'apples'],
      zipCode = '10001',
      storeId = '2055', // Bridgewater NJ
      maxResultsPerTerm = 10
    } = options;

    if (this.isRunning) {
      throw new Error('Scraping is already in progress');
    }

    this.isRunning = true;
    const startTime = Date.now();

    try {
      console.log('Starting Target scraping process...');

      // Ensure Target store exists in database
      // Note: Let UUID be auto-generated by database
      const targetStore = await this.ensureStoreExists({
        chainName: 'Target',
        storeName: `Target Store ${storeId}`,
        address: 'Various Locations',
        city: 'New York',
        state: 'NY',
        zipCode: zipCode,
        latitude: 40.7128,
        longitude: -74.0060,
        externalStoreId: storeId // Store Target's store ID separately
      });

      const allScrapedProducts = [];
      const termResults = {};

      // Scrape products for each search term
      for (const searchTerm of searchTerms) {
        try {
          console.log(`Scraping Target products for: ${searchTerm}`);

          const products = await this.targetScraper.searchProducts(
            searchTerm,
            zipCode,
            storeId,
            maxResultsPerTerm
          );

          termResults[searchTerm] = {
            found: products.length,
            withUPC: products.filter(p => p.upc).length,
            withPrice: products.filter(p => p.price !== null).length,
            avgPrice: products.length > 0
              ? (products.reduce((sum, p) => sum + (p.price || 0), 0) / products.filter(p => p.price).length).toFixed(2)
              : 0
          };

          allScrapedProducts.push(...products);

          // Add delay between requests to avoid rate limiting (10 seconds for Target bulk scraping)
          await this.delay(10000);

        } catch (error) {
          console.error(`Error scraping ${searchTerm} from Target:`, error.message);
          termResults[searchTerm] = {
            error: error.message
          };
        }
      }

      // Process and save scraped products to database
      console.log(`Processing ${allScrapedProducts.length} scraped Target products...`);
      const processingResults = await this.productService.processScrapedProducts(
        allScrapedProducts,
        targetStore.storeId // Use the generated UUID
      );

      const endTime = Date.now();
      const duration = Math.round((endTime - startTime) / 1000);

      const results = {
        success: true,
        store: 'Target',
        storeId: storeId,
        duration: `${duration} seconds`,
        searchTerms: searchTerms,
        termResults: termResults,
        totalProductsFound: allScrapedProducts.length,
        processingResults: processingResults,
        timestamp: new Date().toISOString()
      };

      console.log('Target scraping completed successfully:', results);
      return results;

    } catch (error) {
      console.error('Target scraping failed:', error.message);
      throw error;
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Scrape detailed information for specific products
   * @param {Array} productUrls - Array of product URLs to scrape
   * @returns {Promise<object>} - Detailed scraping results
   */
  async scrapeProductDetails(productUrls) {
    if (this.isRunning) {
      throw new Error('Scraping is already in progress');
    }

    this.isRunning = true;
    const startTime = Date.now();

    try {
      console.log(`Scraping details for ${productUrls.length} products...`);
      
      const detailedProducts = [];
      const errors = [];

      for (const productUrl of productUrls) {
        try {
          const productDetails = await this.shopRiteScraper.getProductDetails(productUrl);
          if (productDetails) {
            detailedProducts.push(productDetails);
          }

          // Add delay between requests (15 seconds for ShopRite bulk scraping)
          await this.delay(15000);
          
        } catch (error) {
          console.error(`Error scraping product details ${productUrl}:`, error.message);
          errors.push({
            url: productUrl,
            error: error.message
          });
        }
      }

      // Process detailed products
      const processingResults = await this.productService.processScrapedProducts(
        detailedProducts,
        'shoprite'
      );

      const endTime = Date.now();
      const duration = Math.round((endTime - startTime) / 1000);

      const results = {
        success: true,
        duration: `${duration} seconds`,
        totalUrlsProcessed: productUrls.length,
        successfullyScraped: detailedProducts.length,
        errors: errors.length,
        errorDetails: errors,
        processingResults: processingResults,
        timestamp: new Date().toISOString()
      };

      console.log('Product details scraping completed:', results);
      return results;

    } catch (error) {
      console.error('Product details scraping failed:', error.message);
      throw error;
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Run a comprehensive scraping session
   * @param {object} options - Comprehensive scraping options
   * @returns {Promise<object>} - Complete scraping results
   */
  async runComprehensiveScraping(options = {}) {
    const {
      searchTerms = [
        'milk', 'bread', 'eggs', 'chicken breast', 'ground beef',
        'bananas', 'apples', 'tomatoes', 'lettuce', 'onions',
        'rice', 'pasta', 'cereal', 'yogurt', 'cheese'
      ],
      zipCode = '07001',
      maxResultsPerTerm = 15,
      includeDetailedScraping = false
    } = options;

    try {
      console.log('Starting comprehensive ShopRite scraping...');
      
      // Phase 1: Search-based scraping
      const searchResults = await this.scrapeShopRite({
        searchTerms,
        zipCode,
        maxResultsPerTerm
      });

      let detailResults = null;

      // Phase 2: Detailed scraping (if requested)
      if (includeDetailedScraping) {
        // Get product URLs from search results for detailed scraping
        const productUrls = searchResults.termResults
          ? Object.values(searchResults.termResults)
              .filter(result => !result.error)
              .slice(0, 10) // Limit to 10 for demo
          : [];

        if (productUrls.length > 0) {
          detailResults = await this.scrapeProductDetails(productUrls);
        }
      }

      return {
        success: true,
        searchPhase: searchResults,
        detailPhase: detailResults,
        summary: {
          totalProductsProcessed: searchResults.processingResults.processed + (detailResults?.processingResults.processed || 0),
          totalProductsCreated: searchResults.processingResults.created + (detailResults?.processingResults.created || 0),
          totalErrors: searchResults.processingResults.errors + (detailResults?.processingResults.errors || 0)
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Comprehensive scraping failed:', error.message);
      throw error;
    }
  }

  /**
   * Ensure a store exists in the database
   * @param {object} storeData - Store information
   * @returns {Promise<object>} - Store document
   */
  async ensureStoreExists(storeData) {
    try {
      // Find store by chain name and store name
      let store = await Store.findOne({
        where: {
          chainName: storeData.chainName,
          storeName: storeData.storeName
        }
      });

      if (!store) {
        // Create new store (storeId will be auto-generated UUID)
        store = await Store.create(storeData);
        console.log(`Created store: ${storeData.storeName}`);
      }

      return store;
    } catch (error) {
      console.error('Error ensuring store exists:', error.message);
      throw error;
    }
  }

  /**
   * Get scraping status and statistics
   * @returns {Promise<object>} - Current scraping status
   */
  async getScrapingStatus() {
    try {
      const shopRiteStore = await Store.findOne({
        where: {
          chainName: 'ShopRite',
          storeName: 'ShopRite'
        }
      });

      if (!shopRiteStore) {
        return {
          isRunning: this.isRunning,
          storeConfigured: false,
          message: 'ShopRite store not configured'
        };
      }

      // Get recent scraping statistics
      const recentProducts = await this.productService.getProductsByStore(shopRiteStore.storeId, 10);
      
      return {
        isRunning: this.isRunning,
        storeConfigured: true,
        store: shopRiteStore,
        recentProductCount: recentProducts.length,
        lastScrapedProducts: recentProducts.slice(0, 5).map(p => ({
          name: p.name,
          price: p.price,
          lastUpdated: p.lastUpdated
        }))
      };
    } catch (error) {
      console.error('Error getting scraping status:', error.message);
      return {
        isRunning: this.isRunning,
        error: error.message
      };
    }
  }

  /**
   * Enrich product data by UPC using OpenFoodFacts API
   * @param {string} upc - Product UPC code
   * @returns {Promise<object>} - Enriched product data and save result
   */
  async enrichProductByUPC(upc) {
    try {
      console.log(`Enriching product with UPC: ${upc}`);

      // Fetch product data from OpenFoodFacts
      const productData = await this.openFoodFactsScraper.getProductByUPC(upc);

      if (!productData) {
        return {
          success: false,
          upc: upc,
          message: 'Product not found in OpenFoodFacts database',
          productData: null
        };
      }

      // Save/update product in database
      const saveResult = await this.productService.upsertProduct({
        upc: productData.upc,
        name: productData.name,
        brand: productData.brand,
        size: productData.size,
        category: productData.category,
        imageUrl: productData.imageUrl
      });

      return {
        success: true,
        upc: upc,
        message: saveResult.created ? 'Product created' : 'Product updated',
        productData: productData,
        saveResult: saveResult
      };

    } catch (error) {
      console.error(`Error enriching product ${upc}:`, error.message);
      return {
        success: false,
        upc: upc,
        error: error.message,
        productData: null
      };
    }
  }

  /**
   * Batch enrich multiple products by UPC
   * @param {Array<string>} upcs - Array of UPC codes
   * @returns {Promise<object>} - Batch enrichment results
   */
  async batchEnrichProducts(upcs) {
    if (!Array.isArray(upcs) || upcs.length === 0) {
      throw new Error('UPCs must be a non-empty array');
    }

    const startTime = Date.now();
    console.log(`Starting batch enrichment for ${upcs.length} UPCs...`);

    const results = {
      total: upcs.length,
      successful: 0,
      failed: 0,
      notFound: 0,
      details: []
    };

    for (const upc of upcs) {
      const result = await this.enrichProductByUPC(upc);
      results.details.push(result);

      if (result.success) {
        results.successful++;
      } else if (result.message && result.message.includes('not found')) {
        results.notFound++;
      } else {
        results.failed++;
      }
    }

    const endTime = Date.now();
    const duration = Math.round((endTime - startTime) / 1000);

    results.duration = `${duration} seconds`;
    results.timestamp = new Date().toISOString();

    console.log(`Batch enrichment completed: ${results.successful} successful, ${results.notFound} not found, ${results.failed} failed`);

    return results;
  }

  /**
   * Search products across all available stores (Target + ShopRite)
   * Used by searchProducts GraphQL resolver to return real-time prices
   * @param {string} searchTerm - Product search term
   * @param {object} options - Search options (limit, zipCode, storeId)
   * @returns {Promise<object>} - Results with products from all stores
   */
  async searchProductsAllStores(searchTerm, options = {}) {
    const { limit = 20, zipCode = '10001', targetStoreId = '2055', shopriteStoreId = '3000' } = options;

    const results = {
      searchTerm,
      timestamp: new Date(),
      products: [],
      errors: [],
      sources: {
        target: { found: 0, errors: 0 },
        shoprite: { found: 0, errors: 0 }
      }
    };

    try {
      console.log(`Searching all stores for: "${searchTerm}" (limit: ${limit})`);

      // Ensure stores exist in database
      const [targetStore, shopriteStore] = await Promise.allSettled([
        this.ensureStoreExists({
          chainName: 'Target',
          storeName: `Target Store ${targetStoreId}`,
          address: 'Various Locations',
          city: 'New York',
          state: 'NY',
          zipCode: zipCode,
          latitude: 40.7128,
          longitude: -74.0060,
          externalStoreId: targetStoreId
        }),
        this.ensureStoreExists({
          chainName: 'ShopRite',
          storeName: `ShopRite Store ${shopriteStoreId}`,
          address: 'Various Locations',
          city: 'New York',
          state: 'NY',
          zipCode: zipCode,
          latitude: 40.7128,
          longitude: -74.0060,
          externalStoreId: shopriteStoreId
        })
      ]);

      const targetStoreUUID = targetStore.status === 'fulfilled' ? targetStore.value.storeId : null;
      const shopriteStoreUUID = shopriteStore.status === 'fulfilled' ? shopriteStore.value.storeId : null;

      // Scrape Target and ShopRite in parallel
      const [targetResults, shopriteResults] = await Promise.allSettled([
        this.targetScraper
          ? this.targetScraper.searchProducts(searchTerm, zipCode, targetStoreId, Math.ceil(limit / 2))
          : Promise.resolve([]),
        this.shopRiteScraper.searchProducts(searchTerm, shopriteStoreId, zipCode, Math.ceil(limit / 2))
      ]);

      // Process Target results
      if (targetResults.status === 'fulfilled') {
        const targetProducts = targetResults.value || [];
        console.log(`Target returned ${targetProducts.length} products`);
        results.sources.target.found = targetProducts.length;

        // Save to database
        for (const product of targetProducts) {
          try {
            if (product.upc && product.price !== null && targetStoreUUID) {
              // Create/update product with TCIN (may return existing product if fuzzy match found)
              const savedProduct = await this.productService.createOrUpdateProduct({
                upc: product.upc,
                tcin: product.tcin, // Store Target's internal ID
                name: product.name,
                brand: product.brand,
                size: product.size,
                category: product.category,
                imageUrl: product.imageUrl || product.image
              });

              // Create/update store price using the ACTUAL saved product UPC
              // (important when fuzzy matcher reuses existing product)
              await this.productService.createOrUpdateStorePrice({
                upc: savedProduct.upc,
                storeId: targetStoreUUID,
                price: product.price,
                dealType: product.dealType || 'regular'
              });

              // Enrich Target products with real UPC from OpenFoodFacts (async, non-blocking)
              if (product.needsEnrichment) {
                this.enrichTargetProductUPC(product).catch(err => {
                  console.warn(`Background UPC enrichment failed for ${product.name}:`, err.message);
                });
              }
            }
          } catch (error) {
            console.error(`Error saving Target product ${product.name}:`, error.message);
            results.sources.target.errors++;
          }
        }

        results.products.push(...targetProducts);
      } else {
        console.error('Target scraping failed:', targetResults.reason?.message);
        results.errors.push({ store: 'target', error: targetResults.reason?.message || 'Unknown error' });
        results.sources.target.errors++;
      }

      // Process ShopRite results
      if (shopriteResults.status === 'fulfilled') {
        const shopriteProducts = shopriteResults.value || [];
        console.log(`ShopRite returned ${shopriteProducts.length} products`);
        results.sources.shoprite.found = shopriteProducts.length;

        // Save to database
        for (const product of shopriteProducts) {
          try {
            if (product.upc && product.price !== null && shopriteStoreUUID) {
              // Create/update product (may return existing product if fuzzy match found)
              const savedProduct = await this.productService.createOrUpdateProduct({
                upc: product.upc,
                name: product.name,
                brand: product.brand,
                size: product.size,
                category: product.category,
                imageUrl: product.imageUrl || product.image
              });

              // Create/update store price using the ACTUAL saved product UPC
              // (important when fuzzy matcher reuses existing product)
              await this.productService.createOrUpdateStorePrice({
                upc: savedProduct.upc,
                storeId: shopriteStoreUUID,
                price: product.price,
                dealType: product.dealType || 'regular'
              });
            }
          } catch (error) {
            console.error(`Error saving ShopRite product ${product.name}:`, error.message);
            results.sources.shoprite.errors++;
          }
        }

        results.products.push(...shopriteProducts);
      } else {
        console.error('ShopRite scraping failed:', shopriteResults.reason?.message);
        results.errors.push({ store: 'shoprite', error: shopriteResults.reason?.message || 'Unknown error' });
        results.sources.shoprite.errors++;
      }

      // Close ShopRite browser to free resources
      if (shopriteResults.status === 'fulfilled') {
        await this.shopRiteScraper.close();
      }

      // Deduplicate by UPC (prefer products with prices)
      const productMap = new Map();
      results.products.forEach(product => {
        const key = product.upc || product.name;
        const existing = productMap.get(key);

        // Prefer products with valid prices
        if (!existing || (product.price !== null && existing.price === null)) {
          productMap.set(key, product);
        }
      });

      results.products = Array.from(productMap.values()).slice(0, limit);

      console.log(`Total products found: ${results.products.length} (Target: ${results.sources.target.found}, ShopRite: ${results.sources.shoprite.found})`);

      return results;

    } catch (error) {
      console.error('Error in searchProductsAllStores:', error.message);
      results.errors.push({ error: error.message });
      throw error;
    }
  }

  /**
   * Enrich Target product with real UPC from OpenFoodFacts
   * This runs asynchronously in the background after saving a product
   * @param {object} product - Product object with pseudo-UPC
   * @returns {Promise<boolean>} - True if enrichment succeeded
   */
  async enrichTargetProductUPC(product) {
    try {
      console.log(`[UPC Enrichment] Searching for real UPC for: ${product.name}`);

      // Search OpenFoodFacts by product name (+ brand if available)
      const searchTerm = product.brand ? `${product.brand} ${product.name}` : product.name;
      const results = await this.openFoodFactsScraper.searchProducts(searchTerm, 5);

      if (!results || results.length === 0) {
        console.log(`[UPC Enrichment] No matches found in OpenFoodFacts for: ${product.name}`);
        return false;
      }

      // Find the best match (simple matching by name similarity)
      const bestMatch = this.findBestProductMatch(product, results);

      if (!bestMatch || !bestMatch.upc) {
        console.log(`[UPC Enrichment] No suitable UPC found for: ${product.name}`);
        return false;
      }

      // Check if the real UPC is different from pseudo-UPC
      if (bestMatch.upc === product.upc) {
        console.log(`[UPC Enrichment] UPC already correct for: ${product.name}`);
        return false;
      }

      console.log(`[UPC Enrichment] Found real UPC ${bestMatch.upc} for ${product.name} (was ${product.upc})`);

      // Update product in database with real UPC
      // IMPORTANT: We can't change the primary key (UPC), so we need to:
      // 1. Create a new product with the real UPC
      // 2. Transfer all store prices to the new UPC
      // 3. Delete the old pseudo-UPC product

      await this.productService.createOrUpdateProduct({
        upc: bestMatch.upc,
        tcin: product.tcin,
        name: product.name,
        brand: product.brand || bestMatch.brand,
        size: product.size || bestMatch.size,
        category: product.category || bestMatch.category,
        imageUrl: product.imageUrl || bestMatch.imageUrl,
        isEnriched: true
      });

      // TODO: Transfer store prices from pseudo-UPC to real UPC
      // This requires updating StorePrices table to point to new UPC
      // For now, we'll just create the enriched product
      // The pseudo-UPC product will remain in database until cleanup

      console.log(`[UPC Enrichment] Successfully enriched ${product.name} with real UPC ${bestMatch.upc}`);
      return true;

    } catch (error) {
      console.error(`[UPC Enrichment] Error enriching ${product.name}:`, error.message);
      return false;
    }
  }

  /**
   * Find the best matching product from OpenFoodFacts results
   * Simple matching by name/brand similarity
   * @param {object} targetProduct - The Target product to match
   * @param {Array} offResults - Array of OpenFoodFacts products
   * @returns {object|null} - Best matching product or null
   */
  findBestProductMatch(targetProduct, offResults) {
    if (!offResults || offResults.length === 0) {
      return null;
    }

    // Simple matching: look for products with similar names
    // In production, this could be more sophisticated (Levenshtein distance, etc.)
    const targetName = targetProduct.name.toLowerCase();
    const targetBrand = (targetProduct.brand || '').toLowerCase();

    let bestMatch = null;
    let bestScore = 0;

    for (const result of offResults) {
      let score = 0;
      const resultName = (result.name || '').toLowerCase();
      const resultBrand = (result.brand || '').toLowerCase();

      // Score based on name similarity (simple contains check)
      if (resultName.includes(targetName) || targetName.includes(resultName)) {
        score += 3;
      }

      // Score based on brand match
      if (targetBrand && resultBrand && (targetBrand === resultBrand || resultName.includes(targetBrand))) {
        score += 2;
      }

      if (score > bestScore) {
        bestScore = score;
        bestMatch = result;
      }
    }

    // Only return match if score is above threshold
    return bestScore >= 3 ? bestMatch : null;
  }

  /**
   * Utility function to add delay between requests
   * @param {number} ms - Milliseconds to delay
   * @returns {Promise} - Promise that resolves after delay
   */
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = ScrapingOrchestrator;

